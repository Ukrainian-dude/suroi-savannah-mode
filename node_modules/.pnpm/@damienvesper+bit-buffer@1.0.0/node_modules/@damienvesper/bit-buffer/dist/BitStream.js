"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitStream = void 0;
const BitView_1 = require("./BitView");
const utils_1 = require("./utils");
/**
 * Small wrapper for a BitView to maintain position,
 * as well as to handle reading / writing of string data
 * to the underlying buffer.
 */
class BitStream {
    _view;
    _startIndex;
    _length;
    _index;
    constructor(source, byteOffset, byteLength) {
        const isBuffer = source instanceof ArrayBuffer ||
            (typeof Buffer !== `undefined` && source instanceof Buffer);
        if (!(source instanceof BitView_1.BitView) && !isBuffer) {
            throw new Error(`Must specify a valid BitView, ArrayBuffer or Buffer`);
        }
        byteOffset = byteOffset ?? 0;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        byteLength = (byteLength ?? 0) || ((source instanceof ArrayBuffer || source instanceof BitView_1.BitView) ? source.byteLength : source.length);
        this._view = !(source instanceof BitView_1.BitView)
            ? new BitView_1.BitView(source, byteOffset, byteLength)
            : source;
        this._index = 0;
        this._startIndex = 0;
        this._length = this._view.byteLength * 8;
    }
    get index() {
        return this._index - this._startIndex;
    }
    set index(val) {
        this._index = val + this._startIndex;
    }
    get length() {
        return this._length - this._startIndex;
    }
    set length(val) {
        this._length = val + this._startIndex;
    }
    get bitsLeft() {
        return this._length - this._index;
    }
    get byteIndex() {
        return Math.ceil(this._index / 8);
    }
    set byteIndex(val) {
        this._index = val * 8;
    }
    get buffer() {
        return this._view.buffer;
    }
    get view() {
        return this._view;
    }
    get bigEndian() {
        return this._view.bigEndian;
    }
    set bigEndian(val) {
        this._view.bigEndian = val;
    }
    reader = (name, size) => () => {
        if (this._index + size > this._length) {
            throw new Error(`Trying to read past the end of the stream`);
        }
        const val = this._view[name](this._index);
        this._index += size;
        return val;
    };
    writer = (name, size) => (value) => {
        this._view[name](this._index, value);
        this._index += size;
    };
    readBits = (bits, signed) => {
        const val = this._view.getBits(this._index, bits, signed ?? false);
        this._index += bits;
        return val;
    };
    writeBits = (value, bits) => {
        this._view.setBits(this._index, value, bits);
        this._index += bits;
    };
    readBoolean = this.reader(`getBoolean`, 1);
    readInt8 = this.reader(`getInt8`, 8);
    readInt16 = this.reader(`getInt16`, 16);
    readInt32 = this.reader(`getInt32`, 32);
    readUint8 = this.reader(`getUint8`, 8);
    readUint16 = this.reader(`getUint16`, 16);
    readUint32 = this.reader(`getUint32`, 32);
    readFloat32 = this.reader(`getFloat32`, 32);
    readFloat64 = this.reader(`getFloat64`, 64);
    writeBoolean = this.writer(`setBoolean`, 1);
    writeInt8 = this.writer(`setInt8`, 8);
    writeInt16 = this.writer(`setInt16`, 16);
    writeInt32 = this.writer(`setInt32`, 32);
    writeUint8 = this.writer(`setUint8`, 8);
    writeUint16 = this.writer(`setUint16`, 16);
    writeUint32 = this.writer(`setUint32`, 32);
    writeFloat32 = this.writer(`setFloat32`, 32);
    writeFloat64 = this.writer(`setFloat64`, 64);
    readASCIIString = (bytes) => (0, utils_1.readASCIIString)(this, this._length, this._index, bytes);
    readUTF8String = (bytes) => (0, utils_1.readUTF8String)(this, this._length, this._index, bytes);
    writeASCIIString = (string, bytes) => {
        (0, utils_1.writeASCIIString)(this, string, bytes);
    };
    writeUTF8String = (string, bytes) => {
        (0, utils_1.writeUTF8String)(this, string, bytes);
    };
    readBitStream = (bitLength) => {
        const slice = new BitStream(this._view);
        slice._startIndex = this._index;
        slice._index = this._index;
        slice.length = bitLength;
        this._index += bitLength;
        return slice;
    };
    writeBitStream = (stream, length) => {
        if (length === undefined)
            length = stream.bitsLeft;
        let bitsToWrite;
        while (length > 0) {
            bitsToWrite = Math.min(length, 32);
            this.writeBits(stream.readBits(bitsToWrite), bitsToWrite);
            length -= bitsToWrite;
        }
    };
    readArrayBuffer = (byteLength) => {
        const buffer = this._view.getArrayBuffer(this._index, byteLength);
        this._index += (byteLength * 8);
        return buffer;
    };
    writeArrayBuffer = (buffer, byteLength) => {
        this.writeBitStream(new BitStream(buffer), byteLength * 8);
    };
}
exports.BitStream = BitStream;
//# sourceMappingURL=BitStream.js.map